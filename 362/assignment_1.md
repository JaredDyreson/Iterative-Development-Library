# Assignment 1 : Summary of Chapter 1

Author: Jared Dyreson

Email: jareddyreson@csu.fullerton.edu

Class: CS-362:07 (Sat 09:00 - 12:45)

When creating a large scale project, the code written needs to be robust enough to keep up with the future and competition that will eventually rise.
There are just some things that we cannot foresee; such as the lasting impact of software we write to the creation of new fields of study.
With that being said, software serves two purposes; being an independent unit or the vessel that transmits another unit.
The level of care and precision put into the development of this software is paramount to help mitigate large hurdles that plague even the best and most robust companies.
Even though software doesn't break down like it's hardware counterpart, it does depreciate over time.
For example, Python 2.7 was finally put to rest at the beginning of 2020 after being in use for exactly 20 years.
During it's lifetime, it acquired several quirks that couldn't just be ironed out in a few patches; it required major rewrites to the codebase.

Some pieces of software occupy a certain niche or "domain" of influence.
These domains are as follows:

- Application
- Engineering/scientific
- Embedded
- Product-line
- Web/Mobile
- AI

Each serve to cater to a specific marketplace, addressing needs accordingly.
Another category much broader than the above is legacy software.
These codebases must be kept alive as some system critical components require it's uptime.
For example, COVID-19 saw the rise in unemployment from March to July 2020 and people needed to get their unemployment checks mailed to them.
These systems were running COBAL, which was developed in the early 60's and is still used today in banking transactions. It was also used by, you guessed it, distribution services by the American government.
This shows the importance of revitalizing of archaic systems that serve a key role in everyday life.

Over the lifetime of a platform, tasks that are expected can change rapidly.
The internet pre Y2K was full of simple HTML pages that were originally used by universities to communicate or simple chat rooms powered by dial-up.
We then saw the importance of anonymity and security for end users.
This then sparked large efforts to make this new space to be more structured and have set rules.

With the emergence of phones and mobile devices, there was also another large push to develop simple user interfaces that pandered to this new audience.
Both of these innovations came because of faster/cheaper computers that allowed for cloud computing that could work on behalf of these devices.
Therefore allowing for smaller devices to have larger access to information and different services.
You could think of mobile devices as remotes, giving certain instructions for larger machines to perform large tasks and handing back results.

Software is a complex topic and it's use cases are innumerable.
We have seen the evolution of certain spheres of software ranging from the internet and to the mobile device in your pocket.
All of these rapid changes need to be kept up with and one way to do so is writing flexible and dynamic codebases.
Since this industry moves quickly in producing such inventions, we as software engineers need to do the same in keeping up.


# Hello World

```python
#!/usr/bin/env python3.8
print("Hello World")
print(f'{1 + 1} = 2')
```

![Output](/home/jared/Selection_012.png)
