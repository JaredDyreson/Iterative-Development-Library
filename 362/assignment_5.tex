\documentclass{article}

\usepackage{mathrsfs,amsmath}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{minted}
\usepackage{mwe}

\usepackage[margin=1.4in]{geometry}

\title{Assignment \#5 | CS 362 Software Engineering}
\author{Jared Dyreson \\
        jareddyreson@csu.fullerton.edu \\
        California State University, Fullerton}
\date

\DeclareRobustCommand{\bowtie}{%
  \mathrel\triangleright\joinrel\mathrel\triangleleft}


\usepackage [english]{babel}
\usepackage [autostyle, english = american]{csquotes}
\MakeOuterQuote{"}

\titlespacing*{\section}
{0pt}{5.5ex plus 1ex minus .2ex}{4.3ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5.5ex plus 1ex minus .2ex}{4.3ex plus .2ex}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Chapter 22 | Object-Oriented Design}

OOD (Object-Oriented Design) is the philosophy in which components are designed in a readable fashion while allowing for re-usability.
For example, if you are designing a program that records employees punch cards, it would be smart to make the code as extensible as possible.
Using generic class names such as "Employee" and "PunchLogHistory" can help solidify what each component does.
This is seen also in design decision and coupling, where dependencies are too interwoven with one another, making it hard to debug.

It is important to make clear distinctions in which this process is conducted into specific layers:

\begin{enumerate}
\item Subsystem : customer defined requirements
\item Class and Objects : hierarchies defined in classes and relationships explicitly defined
\item Message : how each class communicates with one another
\item Responsibilities : algorithms and data structures that are deployed to bind them together.
\end{enumerate}

In some cases it is needed for an OOA model to be transcribed into a OOD model and can be done achieved effectively.
During the design process of each class and relationship model, it is important to keep them distinct from another, so that small changes made to one can easily manifest in others.
It also helps with readability and understandability amongst other programmers.
These goals can be achieved using a multitude of different methods, emphasizing certain stages over others.
The end product should be the same and all that matters is what you produce.

Some of these methods are stitched together using models and notation to help delineate crucial steps.
One such idea is in the form of \emph{UML (Unified Modeling Language) object design} and it describes the relationships between objects.
It helps in the construction of the design of the subsystems and individual objects.
Using this model helps show reusable objects, cutting down on time strictly programming.

\section{Chapter 23 | Object-Oriented Testing}

Even though reusing code is extraordinarily convenient, it does unfortunately require more testing.
Consistency and completeness must be wholly considered when creating unit tests for each component.
This ensures that objects are fully represented in implementation.
In some cases, extraneous attributes are applied to a class and manipulated in other method calls simply because instructions were unclear.
This leads to wasted time and could have been used to tackle larger issues that plague the project.

Inherited classes are sometimes wrought with issues, because they are given functionality that may not be used.
Data given to those instances might not be handled correctly, leading to disastrous consequences.
It is also important to relegate each class into their own separate namespace, allowing for them to act in accordance to guidelines set out in design.

Each individual class needs to be exhaustively tested to make sure that it's abstraction encompasses all edge cases.
These unit tests are meant to attempt to break or disrupt the program in a controlled environment, making sure that these do not manifest in production.
This is called scenario-based testing.

Random testing can also be employed to try to find niche edge cases that might have been otherwise overlooked in initial testing.
It also can be quickly deployed because the data is generated by the computer itself, rather than hand typed into the system by a human.
Sequences of commands can also be randomly called and to see how the system reacts to said requests.

When testing classes that contain other classes, "interclass test case generation" is applied.
The best example is in the form of an ATM, where there are six different components talking to each other at any given time.
All of these endpoints have their own class implementation and external function calls.

\end{document}
